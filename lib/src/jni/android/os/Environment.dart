// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

import '../../java/io/File.dart' as file_;

/// from: `android.os.Environment`
class Environment extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Environment> $type;

  @_$jni.internal
  Environment.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'android/os/Environment');

  /// The type which includes information such as the signature of this class.
  static const type = $Environment$Type();
  static final _id_DIRECTORY_ALARMS = _class.staticFieldId(
    r'DIRECTORY_ALARMS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_ALARMS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_ALARMS =>
      _id_DIRECTORY_ALARMS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_ALARMS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_ALARMS(_$jni.JString value) =>
      _id_DIRECTORY_ALARMS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_AUDIOBOOKS = _class.staticFieldId(
    r'DIRECTORY_AUDIOBOOKS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_AUDIOBOOKS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_AUDIOBOOKS =>
      _id_DIRECTORY_AUDIOBOOKS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_AUDIOBOOKS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_AUDIOBOOKS(_$jni.JString value) =>
      _id_DIRECTORY_AUDIOBOOKS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_DCIM = _class.staticFieldId(
    r'DIRECTORY_DCIM',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_DCIM`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_DCIM =>
      _id_DIRECTORY_DCIM.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_DCIM`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_DCIM(_$jni.JString value) =>
      _id_DIRECTORY_DCIM.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_DOCUMENTS = _class.staticFieldId(
    r'DIRECTORY_DOCUMENTS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_DOCUMENTS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_DOCUMENTS =>
      _id_DIRECTORY_DOCUMENTS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_DOCUMENTS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_DOCUMENTS(_$jni.JString value) =>
      _id_DIRECTORY_DOCUMENTS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_DOWNLOADS = _class.staticFieldId(
    r'DIRECTORY_DOWNLOADS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_DOWNLOADS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_DOWNLOADS =>
      _id_DIRECTORY_DOWNLOADS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_DOWNLOADS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_DOWNLOADS(_$jni.JString value) =>
      _id_DIRECTORY_DOWNLOADS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_MOVIES = _class.staticFieldId(
    r'DIRECTORY_MOVIES',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_MOVIES`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_MOVIES =>
      _id_DIRECTORY_MOVIES.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_MOVIES`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_MOVIES(_$jni.JString value) =>
      _id_DIRECTORY_MOVIES.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_MUSIC = _class.staticFieldId(
    r'DIRECTORY_MUSIC',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_MUSIC`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_MUSIC =>
      _id_DIRECTORY_MUSIC.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_MUSIC`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_MUSIC(_$jni.JString value) =>
      _id_DIRECTORY_MUSIC.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_NOTIFICATIONS = _class.staticFieldId(
    r'DIRECTORY_NOTIFICATIONS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_NOTIFICATIONS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_NOTIFICATIONS =>
      _id_DIRECTORY_NOTIFICATIONS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_NOTIFICATIONS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_NOTIFICATIONS(_$jni.JString value) =>
      _id_DIRECTORY_NOTIFICATIONS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_PICTURES = _class.staticFieldId(
    r'DIRECTORY_PICTURES',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_PICTURES`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_PICTURES =>
      _id_DIRECTORY_PICTURES.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_PICTURES`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_PICTURES(_$jni.JString value) =>
      _id_DIRECTORY_PICTURES.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_PODCASTS = _class.staticFieldId(
    r'DIRECTORY_PODCASTS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_PODCASTS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_PODCASTS =>
      _id_DIRECTORY_PODCASTS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_PODCASTS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_PODCASTS(_$jni.JString value) =>
      _id_DIRECTORY_PODCASTS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_RECORDINGS = _class.staticFieldId(
    r'DIRECTORY_RECORDINGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_RECORDINGS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_RECORDINGS =>
      _id_DIRECTORY_RECORDINGS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_RECORDINGS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_RECORDINGS(_$jni.JString value) =>
      _id_DIRECTORY_RECORDINGS.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_RINGTONES = _class.staticFieldId(
    r'DIRECTORY_RINGTONES',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_RINGTONES`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_RINGTONES =>
      _id_DIRECTORY_RINGTONES.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_RINGTONES`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_RINGTONES(_$jni.JString value) =>
      _id_DIRECTORY_RINGTONES.set(_class, const _$jni.JStringType(), value);

  static final _id_DIRECTORY_SCREENSHOTS = _class.staticFieldId(
    r'DIRECTORY_SCREENSHOTS',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String DIRECTORY_SCREENSHOTS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DIRECTORY_SCREENSHOTS =>
      _id_DIRECTORY_SCREENSHOTS.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String DIRECTORY_SCREENSHOTS`
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_SCREENSHOTS(_$jni.JString value) =>
      _id_DIRECTORY_SCREENSHOTS.set(_class, const _$jni.JStringType(), value);

  static final _id_MEDIA_BAD_REMOVAL = _class.staticFieldId(
    r'MEDIA_BAD_REMOVAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_BAD_REMOVAL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_BAD_REMOVAL =>
      _id_MEDIA_BAD_REMOVAL.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_CHECKING = _class.staticFieldId(
    r'MEDIA_CHECKING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_CHECKING`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_CHECKING =>
      _id_MEDIA_CHECKING.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_EJECTING = _class.staticFieldId(
    r'MEDIA_EJECTING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_EJECTING`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_EJECTING =>
      _id_MEDIA_EJECTING.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_MOUNTED = _class.staticFieldId(
    r'MEDIA_MOUNTED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_MOUNTED`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_MOUNTED =>
      _id_MEDIA_MOUNTED.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_MOUNTED_READ_ONLY = _class.staticFieldId(
    r'MEDIA_MOUNTED_READ_ONLY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_MOUNTED_READ_ONLY`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_MOUNTED_READ_ONLY =>
      _id_MEDIA_MOUNTED_READ_ONLY.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_NOFS = _class.staticFieldId(
    r'MEDIA_NOFS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_NOFS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_NOFS =>
      _id_MEDIA_NOFS.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_REMOVED = _class.staticFieldId(
    r'MEDIA_REMOVED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_REMOVED`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_REMOVED =>
      _id_MEDIA_REMOVED.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_SHARED = _class.staticFieldId(
    r'MEDIA_SHARED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_SHARED`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_SHARED =>
      _id_MEDIA_SHARED.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_UNKNOWN = _class.staticFieldId(
    r'MEDIA_UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_UNKNOWN`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_UNKNOWN =>
      _id_MEDIA_UNKNOWN.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_UNMOUNTABLE = _class.staticFieldId(
    r'MEDIA_UNMOUNTABLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_UNMOUNTABLE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_UNMOUNTABLE =>
      _id_MEDIA_UNMOUNTABLE.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_UNMOUNTED = _class.staticFieldId(
    r'MEDIA_UNMOUNTED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_UNMOUNTED`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MEDIA_UNMOUNTED =>
      _id_MEDIA_UNMOUNTED.get(_class, const _$jni.JStringType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Environment() {
    return Environment.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getRootDirectory = _class.staticMethodId(
    r'getRootDirectory',
    r'()Ljava/io/File;',
  );

  static final _getRootDirectory = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.io.File getRootDirectory()`
  /// The returned object must be released after use, by calling the [release] method.
  static file_.File getRootDirectory() {
    return _getRootDirectory(_class.reference.pointer,
            _id_getRootDirectory as _$jni.JMethodIDPtr)
        .object(const file_.$File$Type());
  }

  static final _id_getStorageDirectory = _class.staticMethodId(
    r'getStorageDirectory',
    r'()Ljava/io/File;',
  );

  static final _getStorageDirectory = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.io.File getStorageDirectory()`
  /// The returned object must be released after use, by calling the [release] method.
  static file_.File getStorageDirectory() {
    return _getStorageDirectory(_class.reference.pointer,
            _id_getStorageDirectory as _$jni.JMethodIDPtr)
        .object(const file_.$File$Type());
  }

  static final _id_getDataDirectory = _class.staticMethodId(
    r'getDataDirectory',
    r'()Ljava/io/File;',
  );

  static final _getDataDirectory = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.io.File getDataDirectory()`
  /// The returned object must be released after use, by calling the [release] method.
  static file_.File getDataDirectory() {
    return _getDataDirectory(_class.reference.pointer,
            _id_getDataDirectory as _$jni.JMethodIDPtr)
        .object(const file_.$File$Type());
  }

  static final _id_getExternalStorageDirectory = _class.staticMethodId(
    r'getExternalStorageDirectory',
    r'()Ljava/io/File;',
  );

  static final _getExternalStorageDirectory =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `static public java.io.File getExternalStorageDirectory()`
  /// The returned object must be released after use, by calling the [release] method.
  static file_.File getExternalStorageDirectory() {
    return _getExternalStorageDirectory(_class.reference.pointer,
            _id_getExternalStorageDirectory as _$jni.JMethodIDPtr)
        .object(const file_.$File$Type());
  }

  static final _id_getExternalStoragePublicDirectory = _class.staticMethodId(
    r'getExternalStoragePublicDirectory',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getExternalStoragePublicDirectory =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public java.io.File getExternalStoragePublicDirectory(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static file_.File getExternalStoragePublicDirectory(
    _$jni.JString string,
  ) {
    return _getExternalStoragePublicDirectory(
            _class.reference.pointer,
            _id_getExternalStoragePublicDirectory as _$jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const file_.$File$Type());
  }

  static final _id_getDownloadCacheDirectory = _class.staticMethodId(
    r'getDownloadCacheDirectory',
    r'()Ljava/io/File;',
  );

  static final _getDownloadCacheDirectory = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.io.File getDownloadCacheDirectory()`
  /// The returned object must be released after use, by calling the [release] method.
  static file_.File getDownloadCacheDirectory() {
    return _getDownloadCacheDirectory(_class.reference.pointer,
            _id_getDownloadCacheDirectory as _$jni.JMethodIDPtr)
        .object(const file_.$File$Type());
  }

  static final _id_getExternalStorageState = _class.staticMethodId(
    r'getExternalStorageState',
    r'()Ljava/lang/String;',
  );

  static final _getExternalStorageState = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getExternalStorageState()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString getExternalStorageState() {
    return _getExternalStorageState(_class.reference.pointer,
            _id_getExternalStorageState as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_getStorageState = _class.staticMethodId(
    r'getStorageState',
    r'(Ljava/io/File;)Ljava/lang/String;',
  );

  static final _getStorageState = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public java.lang.String getStorageState(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString getStorageState(
    file_.File file,
  ) {
    return _getStorageState(_class.reference.pointer,
            _id_getStorageState as _$jni.JMethodIDPtr, file.reference.pointer)
        .object(const _$jni.JStringType());
  }

  static final _id_getExternalStorageState$1 = _class.staticMethodId(
    r'getExternalStorageState',
    r'(Ljava/io/File;)Ljava/lang/String;',
  );

  static final _getExternalStorageState$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public java.lang.String getExternalStorageState(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString getExternalStorageState$1(
    file_.File file,
  ) {
    return _getExternalStorageState$1(
            _class.reference.pointer,
            _id_getExternalStorageState$1 as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .object(const _$jni.JStringType());
  }

  static final _id_isExternalStorageRemovable = _class.staticMethodId(
    r'isExternalStorageRemovable',
    r'()Z',
  );

  static final _isExternalStorageRemovable =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `static public boolean isExternalStorageRemovable()`
  static bool isExternalStorageRemovable() {
    return _isExternalStorageRemovable(_class.reference.pointer,
            _id_isExternalStorageRemovable as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageRemovable$1 = _class.staticMethodId(
    r'isExternalStorageRemovable',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageRemovable$1 =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallStaticBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public boolean isExternalStorageRemovable(java.io.File file)`
  static bool isExternalStorageRemovable$1(
    file_.File file,
  ) {
    return _isExternalStorageRemovable$1(
            _class.reference.pointer,
            _id_isExternalStorageRemovable$1 as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }

  static final _id_isExternalStorageEmulated = _class.staticMethodId(
    r'isExternalStorageEmulated',
    r'()Z',
  );

  static final _isExternalStorageEmulated = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public boolean isExternalStorageEmulated()`
  static bool isExternalStorageEmulated() {
    return _isExternalStorageEmulated(_class.reference.pointer,
            _id_isExternalStorageEmulated as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageEmulated$1 = _class.staticMethodId(
    r'isExternalStorageEmulated',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageEmulated$1 =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallStaticBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public boolean isExternalStorageEmulated(java.io.File file)`
  static bool isExternalStorageEmulated$1(
    file_.File file,
  ) {
    return _isExternalStorageEmulated$1(
            _class.reference.pointer,
            _id_isExternalStorageEmulated$1 as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }

  static final _id_isExternalStorageLegacy = _class.staticMethodId(
    r'isExternalStorageLegacy',
    r'()Z',
  );

  static final _isExternalStorageLegacy = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public boolean isExternalStorageLegacy()`
  static bool isExternalStorageLegacy() {
    return _isExternalStorageLegacy(_class.reference.pointer,
            _id_isExternalStorageLegacy as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageLegacy$1 = _class.staticMethodId(
    r'isExternalStorageLegacy',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageLegacy$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public boolean isExternalStorageLegacy(java.io.File file)`
  static bool isExternalStorageLegacy$1(
    file_.File file,
  ) {
    return _isExternalStorageLegacy$1(
            _class.reference.pointer,
            _id_isExternalStorageLegacy$1 as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }

  static final _id_isExternalStorageManager = _class.staticMethodId(
    r'isExternalStorageManager',
    r'()Z',
  );

  static final _isExternalStorageManager = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public boolean isExternalStorageManager()`
  static bool isExternalStorageManager() {
    return _isExternalStorageManager(_class.reference.pointer,
            _id_isExternalStorageManager as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageManager$1 = _class.staticMethodId(
    r'isExternalStorageManager',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageManager$1 =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallStaticBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public boolean isExternalStorageManager(java.io.File file)`
  static bool isExternalStorageManager$1(
    file_.File file,
  ) {
    return _isExternalStorageManager$1(
            _class.reference.pointer,
            _id_isExternalStorageManager$1 as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }
}

final class $Environment$Type extends _$jni.JObjType<Environment> {
  @_$jni.internal
  const $Environment$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroid/os/Environment;';

  @_$jni.internal
  @_$core.override
  Environment fromReference(_$jni.JReference reference) =>
      Environment.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Environment$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Environment$Type) &&
        other is $Environment$Type;
  }
}
